<!doctype html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Neon Drift X</title>
    <style>
      :root {
        color-scheme: dark;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        display: grid;
        place-items: center;
        font-family: "Segoe UI", Tahoma, sans-serif;
        color: #eef4ff;
        background: radial-gradient(circle at 20% 0%, #302b80 0, #120c39 34%, #05050e 100%);
      }

      .shell {
        width: min(94vw, 920px);
        border-radius: 18px;
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(7, 8, 18, 0.8);
        box-shadow: 0 30px 100px rgba(0, 0, 0, 0.55);
      }

      .hud {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: center;
        justify-content: space-between;
        padding: 12px 14px;
        background: linear-gradient(90deg, rgba(114, 91, 255, 0.3), rgba(81, 233, 255, 0.1));
        font-size: 0.95rem;
      }

      .title {
        font-weight: 700;
      }

      .pill {
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.08);
        padding: 6px 10px;
        border-radius: 999px;
      }

      #game {
        width: 100%;
        height: auto;
        display: block;
      }

      .controls {
        color: #c7d3ff;
        padding: 12px 14px 16px;
        font-size: 0.9rem;
        line-height: 1.45;
      }

      kbd {
        border-radius: 5px;
        padding: 1px 6px;
        font-size: 0.86em;
        border: 1px solid rgba(255, 255, 255, 0.25);
        border-bottom-width: 2px;
        background: rgba(255, 255, 255, 0.06);
        font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      }
    </style>
  </head>
  <body>
    <main class="shell">
      <header class="hud">
        <span class="title">üéÆ Neon Drift X</span>
        <span class="pill">–°–ª–æ–∂–Ω–æ—Å—Ç—å: <span id="difficultyName">Normal</span></span>
        <span class="pill">–°—á—ë—Ç: <span id="score">0</span></span>
        <span class="pill">–†–µ–∫–æ—Ä–¥: <span id="best">0</span></span>
        <span class="pill">HP: <span id="hp">3</span></span>
        <span class="pill">–ö–æ–º–±–æ: <span id="combo">x1.0</span></span>
        <span class="pill" id="status">–í—ã–±–µ—Ä–∏ —Å–ª–æ–∂–Ω–æ—Å—Ç—å: 1/2/3</span>
      </header>
      <canvas id="game" width="920" height="540"></canvas>
      <div class="controls">
        –î–≤–∏–∂–µ–Ω–∏–µ: <kbd>‚Üê</kbd><kbd>‚Üí</kbd> –∏–ª–∏ <kbd>A</kbd><kbd>D</kbd>. 
        –†—ã–≤–æ–∫: <kbd>Shift</kbd> (–¥–∞—ë—Ç –Ω–µ—É—è–∑–≤–∏–º–æ—Å—Ç—å –Ω–∞ –∫–æ—Ä–æ—Ç–∫–æ–µ –≤—Ä–µ–º—è, –µ—Å—Ç—å –∫—É–ª–¥–∞—É–Ω). 
        –ü–∞—É–∑–∞: <kbd>P</kbd>. 
        –°–ª–æ–∂–Ω–æ—Å—Ç—å: <kbd>1</kbd> Easy, <kbd>2</kbd> Normal, <kbd>3</kbd> Hard. 
        –°—Ç–∞—Ä—Ç/—Ä–µ—Å—Ç–∞—Ä—Ç: <kbd>Space</kbd>.
      </div>
    </main>

    <script>
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");

      const scoreEl = document.getElementById("score");
      const bestEl = document.getElementById("best");
      const hpEl = document.getElementById("hp");
      const comboEl = document.getElementById("combo");
      const statusEl = document.getElementById("status");
      const difficultyNameEl = document.getElementById("difficultyName");

      const DIFFICULTIES = {
        easy: {
          label: "Easy",
          key: "1",
          meteorSpawn: 52,
          fastMeteorChance: 0.08,
          scoreRate: 0.08,
          damage: 1,
          maxHp: 4,
          starInterval: [135, 200],
          powerInterval: [260, 340],
        },
        normal: {
          label: "Normal",
          key: "2",
          meteorSpawn: 40,
          fastMeteorChance: 0.18,
          scoreRate: 0.1,
          damage: 1,
          maxHp: 3,
          starInterval: [120, 180],
          powerInterval: [220, 300],
        },
        hard: {
          label: "Hard",
          key: "3",
          meteorSpawn: 28,
          fastMeteorChance: 0.32,
          scoreRate: 0.13,
          damage: 2,
          maxHp: 3,
          starInterval: [105, 150],
          powerInterval: [190, 260],
        },
      };

      const BEST_KEY = "neon-drift-x-best";

      const state = {
        running: false,
        paused: false,
        gameOver: false,
        score: 0,
        best: Number(localStorage.getItem(BEST_KEY) || 0),
        frame: 0,
        difficulty: DIFFICULTIES.normal,
        meteorTimer: 0,
        starTimer: 0,
        powerTimer: 0,
        combo: 1,
        comboTime: 0,
      };

      const player = {
        x: canvas.width / 2 - 30,
        y: canvas.height - 66,
        w: 60,
        h: 24,
        vx: 0,
        speed: 0.72,
        maxSpeed: 8,
        hp: 3,
        invuln: 0,
        shield: 0,
        slowmo: 0,
        dashCd: 0,
        dashFrames: 0,
      };

      const keys = {};
      const meteors = [];
      const stars = [];
      const powers = [];
      const particles = [];
      const trails = [];

      bestEl.textContent = state.best;

      function rand(min, max) {
        return min + Math.random() * (max - min);
      }

      function randInt(min, max) {
        return Math.floor(rand(min, max + 1));
      }

      function chooseDifficultyByKey(code) {
        if (code === "Digit1") state.difficulty = DIFFICULTIES.easy;
        if (code === "Digit2") state.difficulty = DIFFICULTIES.normal;
        if (code === "Digit3") state.difficulty = DIFFICULTIES.hard;
        difficultyNameEl.textContent = state.difficulty.label;
        if (!state.running) {
          statusEl.textContent = `–°–ª–æ–∂–Ω–æ—Å—Ç—å ${state.difficulty.label}. –ù–∞–∂–º–∏ Space`;
        }
      }

      function scheduleTimer(range) {
        return randInt(range[0], range[1]);
      }

      function resetGame() {
        state.running = true;
        state.paused = false;
        state.gameOver = false;
        state.score = 0;
        state.frame = 0;
        state.combo = 1;
        state.comboTime = 0;
        state.meteorTimer = 0;
        state.starTimer = scheduleTimer(state.difficulty.starInterval);
        state.powerTimer = scheduleTimer(state.difficulty.powerInterval);

        player.x = canvas.width / 2 - player.w / 2;
        player.vx = 0;
        player.hp = state.difficulty.maxHp;
        player.invuln = 0;
        player.shield = 0;
        player.slowmo = 0;
        player.dashCd = 0;
        player.dashFrames = 0;

        meteors.length = 0;
        stars.length = 0;
        powers.length = 0;
        particles.length = 0;
        trails.length = 0;

        statusEl.textContent = "–ü–æ–≥–Ω–∞–ª–∏!";
        updateHud();
      }

      function updateHud() {
        scoreEl.textContent = Math.floor(state.score);
        bestEl.textContent = state.best;
        hpEl.textContent = player.hp;
        comboEl.textContent = `x${state.combo.toFixed(1)}`;
      }

      function spawnMeteor() {
        const size = rand(24, 58);
        const fast = Math.random() < state.difficulty.fastMeteorChance;
        const zigzag = Math.random() < 0.22;
        meteors.push({
          x: rand(0, canvas.width - size),
          y: -size,
          size,
          vy: rand(2.2, 4.4) + state.frame * 0.0009 + (fast ? 2.1 : 0),
          vx: zigzag ? rand(-1.4, 1.4) : 0,
          zigzag,
          phase: rand(0, Math.PI * 2),
          fast,
          spin: rand(-0.12, 0.12),
          angle: rand(0, Math.PI),
        });
      }

      function spawnStar() {
        const size = rand(14, 20);
        stars.push({
          x: rand(0, canvas.width - size),
          y: -size,
          size,
          vy: rand(1.8, 2.8),
          pulse: rand(0, Math.PI * 2),
        });
      }

      function spawnPower() {
        const size = 18;
        const type = Math.random() < 0.5 ? "shield" : "slowmo";
        powers.push({
          x: rand(0, canvas.width - size),
          y: -size,
          size,
          vy: rand(1.9, 2.5),
          type,
          pulse: rand(0, Math.PI * 2),
        });
      }

      function spawnBurst(x, y, color, count = 18) {
        for (let i = 0; i < count; i += 1) {
          particles.push({
            x,
            y,
            vx: rand(-3.8, 3.8),
            vy: rand(-3.8, 3.8),
            life: rand(18, 38),
            color,
          });
        }
      }

      function intersects(a, b) {
        return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
      }

      function addTrail() {
        trails.push({
          x: player.x + player.w / 2,
          y: player.y + player.h / 2,
          life: 11,
        });
      }

      function hitPlayer(dmg) {
        if (player.invuln > 0 || player.dashFrames > 0) return;

        if (player.shield > 0) {
          player.shield = Math.max(0, player.shield - 130);
          player.invuln = 22;
          spawnBurst(player.x + player.w / 2, player.y + player.h / 2, "#71fff6", 12);
          return;
        }

        player.hp -= dmg;
        player.invuln = 50;
        state.combo = 1;
        state.comboTime = 0;
        spawnBurst(player.x + player.w / 2, player.y + player.h / 2, "#ff6f7f", 24);

        if (player.hp <= 0) {
          gameOver();
        }
      }

      function gameOver() {
        state.running = false;
        state.gameOver = true;
        if (state.score > state.best) {
          state.best = Math.floor(state.score);
          localStorage.setItem(BEST_KEY, state.best);
        }
        statusEl.textContent = "‚ò† –ö–æ–Ω–µ—Ü –∏–≥—Ä—ã. Space ‚Äî —Ä–µ—Å—Ç–∞—Ä—Ç";
      }

      function updateGame() {
        if (!state.running || state.paused) return;

        state.frame += 1;

        const timeScale = player.slowmo > 0 ? 0.55 : 1;
        state.score += state.difficulty.scoreRate * state.combo * timeScale;

        const left = keys.ArrowLeft || keys.KeyA;
        const right = keys.ArrowRight || keys.KeyD;

        if (left && !right) player.vx -= player.speed;
        else if (right && !left) player.vx += player.speed;
        else player.vx *= 0.86;

        const localMax = player.dashFrames > 0 ? player.maxSpeed * 1.9 : player.maxSpeed;
        player.vx = Math.max(-localMax, Math.min(localMax, player.vx));
        player.x += player.vx;
        player.x = Math.max(4, Math.min(canvas.width - player.w - 4, player.x));

        if (player.invuln > 0) player.invuln -= 1;
        if (player.shield > 0) player.shield -= 1;
        if (player.slowmo > 0) player.slowmo -= 1;
        if (player.dashCd > 0) player.dashCd -= 1;
        if (player.dashFrames > 0) {
          player.dashFrames -= 1;
          addTrail();
        }

        if (state.comboTime > 0) {
          state.comboTime -= 1;
        } else if (state.combo > 1) {
          state.combo = Math.max(1, state.combo - 0.02);
        }

        state.meteorTimer -= 1;
        if (state.meteorTimer <= 0) {
          spawnMeteor();
          const accel = state.frame * 0.005;
          state.meteorTimer = Math.max(12, state.difficulty.meteorSpawn - accel);
        }

        state.starTimer -= 1;
        if (state.starTimer <= 0) {
          spawnStar();
          state.starTimer = scheduleTimer(state.difficulty.starInterval);
        }

        state.powerTimer -= 1;
        if (state.powerTimer <= 0) {
          spawnPower();
          state.powerTimer = scheduleTimer(state.difficulty.powerInterval);
        }

        const pb = { x: player.x, y: player.y, w: player.w, h: player.h };

        for (let i = meteors.length - 1; i >= 0; i -= 1) {
          const m = meteors[i];
          m.y += m.vy * timeScale;
          m.angle += m.spin;
          if (m.zigzag) {
            m.phase += 0.08;
            m.x += Math.sin(m.phase) * 1.8;
          } else {
            m.x += m.vx * timeScale;
          }

          const mb = { x: m.x + 6, y: m.y + 6, w: m.size - 12, h: m.size - 12 };
          if (intersects(pb, mb)) {
            hitPlayer(state.difficulty.damage);
            meteors.splice(i, 1);
            continue;
          }

          if (m.y > canvas.height + m.size || m.x < -m.size || m.x > canvas.width + m.size) {
            meteors.splice(i, 1);
          }
        }

        for (let i = stars.length - 1; i >= 0; i -= 1) {
          const s = stars[i];
          s.y += s.vy * timeScale;
          s.pulse += 0.1;

          const sb = { x: s.x, y: s.y, w: s.size, h: s.size };
          if (intersects(pb, sb)) {
            state.combo = Math.min(4, state.combo + 0.2);
            state.comboTime = 220;
            state.score += 30 * state.combo;
            spawnBurst(s.x + s.size / 2, s.y + s.size / 2, "#7affea", 16);
            stars.splice(i, 1);
            continue;
          }

          if (s.y > canvas.height + s.size) stars.splice(i, 1);
        }

        for (let i = powers.length - 1; i >= 0; i -= 1) {
          const p = powers[i];
          p.y += p.vy * timeScale;
          p.pulse += 0.1;

          const rb = { x: p.x, y: p.y, w: p.size, h: p.size };
          if (intersects(pb, rb)) {
            if (p.type === "shield") {
              player.shield = Math.min(520, player.shield + 320);
              statusEl.textContent = "üõ° –©–∏—Ç –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω";
              spawnBurst(p.x + p.size / 2, p.y + p.size / 2, "#70fff7", 16);
            } else {
              player.slowmo = 260;
              statusEl.textContent = "üåÄ Slow-mo –≤–∫–ª—é—á–µ–Ω";
              spawnBurst(p.x + p.size / 2, p.y + p.size / 2, "#c197ff", 16);
            }
            powers.splice(i, 1);
            continue;
          }

          if (p.y > canvas.height + p.size) powers.splice(i, 1);
        }

        for (let i = particles.length - 1; i >= 0; i -= 1) {
          const p = particles[i];
          p.x += p.vx;
          p.y += p.vy;
          p.vx *= 0.97;
          p.vy *= 0.97;
          p.life -= 1;
          if (p.life <= 0) particles.splice(i, 1);
        }

        for (let i = trails.length - 1; i >= 0; i -= 1) {
          trails[i].life -= 1;
          if (trails[i].life <= 0) trails.splice(i, 1);
        }

        updateHud();
      }

      function drawShip() {
        const x = player.x;
        const y = player.y;
        const glowColor = player.dashFrames > 0 ? "#ffe271" : "#68f6ff";

        ctx.save();
        ctx.translate(x + player.w / 2, y + player.h / 2);
        ctx.rotate(player.vx * 0.03);

        ctx.fillStyle = glowColor;
        ctx.shadowColor = glowColor;
        ctx.shadowBlur = 16;

        ctx.beginPath();
        ctx.moveTo(-player.w / 2, player.h / 2);
        ctx.lineTo(0, -player.h / 2);
        ctx.lineTo(player.w / 2, player.h / 2);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = "#d8a4ff";
        ctx.fillRect(-8, 2, 16, 6);
        ctx.restore();

        if (player.shield > 0) {
          ctx.strokeStyle = `rgba(113,255,246, ${0.25 + Math.sin(state.frame * 0.15) * 0.2})`;
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.arc(x + player.w / 2, y + player.h / 2, 28, 0, Math.PI * 2);
          ctx.stroke();
        }
      }

      function drawOverlayText() {
        if (state.running) {
          if (state.paused) {
            ctx.fillStyle = "rgba(8,10,20,0.55)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#fff";
            ctx.font = "700 44px Segoe UI";
            ctx.textAlign = "center";
            ctx.fillText("–ü–∞—É–∑–∞", canvas.width / 2, canvas.height / 2);
          }
          return;
        }

        ctx.fillStyle = "rgba(6, 8, 18, 0.66)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#f7f6ff";
        ctx.textAlign = "center";
        ctx.font = "700 44px Segoe UI";
        ctx.fillText("Neon Drift X", canvas.width / 2, canvas.height / 2 - 50);
        ctx.font = "500 24px Segoe UI";
        ctx.fillStyle = "#a2f2ff";
        const msg = state.gameOver ? "Space ‚Äî —Å—ã–≥—Ä–∞—Ç—å –µ—â—ë" : "1/2/3 –≤—ã–±–µ—Ä–∏ —Å–ª–æ–∂–Ω–æ—Å—Ç—å, Space ‚Äî —Å—Ç–∞—Ä—Ç";
        ctx.fillText(msg, canvas.width / 2, canvas.height / 2);
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const bg = ctx.createLinearGradient(0, 0, 0, canvas.height);
        bg.addColorStop(0, player.slowmo > 0 ? "#1c1534" : "#0a0d27");
        bg.addColorStop(1, player.slowmo > 0 ? "#0c1836" : "#031520");
        ctx.fillStyle = bg;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        for (let i = 0; i < 60; i += 1) {
          const x = (i * 173 + state.frame * 0.38) % canvas.width;
          const y = (i * 97 + state.frame * 0.51) % canvas.height;
          const alpha = 0.12 + (i % 5) * 0.1;
          ctx.fillStyle = `rgba(147,177,255,${alpha})`;
          ctx.fillRect(x, y, 2, 2);
        }

        trails.forEach((t) => {
          ctx.globalAlpha = t.life / 11;
          ctx.fillStyle = "#ffe271";
          ctx.beginPath();
          ctx.arc(t.x, t.y, 8 * (t.life / 11), 0, Math.PI * 2);
          ctx.fill();
        });
        ctx.globalAlpha = 1;

        meteors.forEach((m) => {
          ctx.save();
          ctx.translate(m.x + m.size / 2, m.y + m.size / 2);
          ctx.rotate(m.angle);
          ctx.fillStyle = m.fast ? "#ff5f7d" : "#ff8f66";
          ctx.shadowColor = m.fast ? "#ff5f7d" : "#ff8f66";
          ctx.shadowBlur = 12;
          ctx.beginPath();
          for (let i = 0; i < 10; i += 1) {
            const r = i % 2 === 0 ? m.size / 2 : m.size / 2.7;
            const a = (Math.PI * 2 * i) / 10;
            const px = Math.cos(a) * r;
            const py = Math.sin(a) * r;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
          }
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        });

        stars.forEach((s) => {
          const alpha = 0.65 + Math.sin(s.pulse) * 0.28;
          ctx.fillStyle = `rgba(122,255,234,${alpha})`;
          ctx.shadowColor = "#7affea";
          ctx.shadowBlur = 15;
          ctx.beginPath();
          ctx.arc(s.x + s.size / 2, s.y + s.size / 2, s.size / 2, 0, Math.PI * 2);
          ctx.fill();
        });

        powers.forEach((p) => {
          const color = p.type === "shield" ? "#72fff7" : "#ca9aff";
          ctx.fillStyle = color;
          ctx.shadowColor = color;
          ctx.shadowBlur = 16;
          ctx.beginPath();
          ctx.rect(p.x, p.y, p.size, p.size);
          ctx.fill();

          ctx.fillStyle = "#0d1322";
          ctx.font = "700 12px Segoe UI";
          ctx.textAlign = "center";
          ctx.fillText(p.type === "shield" ? "S" : "T", p.x + p.size / 2, p.y + p.size / 2 + 4);
        });

        particles.forEach((p) => {
          ctx.globalAlpha = Math.max(0, p.life / 36);
          ctx.fillStyle = p.color;
          ctx.fillRect(p.x, p.y, 3, 3);
        });

        ctx.globalAlpha = 1;

        if (!(player.invuln > 0 && Math.floor(player.invuln / 4) % 2 === 0)) {
          drawShip();
        }

        if (player.dashCd > 0) {
          ctx.fillStyle = "rgba(255,255,255,0.18)";
          ctx.fillRect(12, canvas.height - 20, 140, 8);
          ctx.fillStyle = "#ffe271";
          ctx.fillRect(12, canvas.height - 20, 140 * (1 - player.dashCd / 130), 8);
        }

        drawOverlayText();
      }

      function loop() {
        updateGame();
        draw();
        requestAnimationFrame(loop);
      }

      window.addEventListener("keydown", (event) => {
        keys[event.code] = true;

        if (event.code === "KeyP" && state.running) {
          state.paused = !state.paused;
          statusEl.textContent = state.paused ? "–ü–∞—É–∑–∞" : "–ò–≥—Ä–∞ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è";
        }

        if (["Digit1", "Digit2", "Digit3"].includes(event.code)) {
          chooseDifficultyByKey(event.code);
        }

        if (event.code === "ShiftLeft" || event.code === "ShiftRight") {
          if (state.running && !state.paused && player.dashCd <= 0) {
            player.dashFrames = 16;
            player.dashCd = 130;
            player.invuln = Math.max(player.invuln, 14);
            const dir = (keys.ArrowLeft || keys.KeyA) ? -1 : 1;
            player.vx += dir * 8;
            statusEl.textContent = "‚ö° –†—ã–≤–æ–∫!";
          }
        }

        if (event.code === "Space") {
          event.preventDefault();
          if (!state.running) {
            resetGame();
          }
        }
      });

      window.addEventListener("keyup", (event) => {
        keys[event.code] = false;
      });

      difficultyNameEl.textContent = state.difficulty.label;
      updateHud();
      draw();
      requestAnimationFrame(loop);
    </script>
  </body>
</html>
